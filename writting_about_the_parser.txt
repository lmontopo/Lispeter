THIS IS A PEICE OF CODE I HAD THAT I THOUGHT WOULD WORK!  IT DIDN'T
BECAUSE HOLDER KEPT COMING BACK TO [ '+', '1', '1', ']'], AND SO OUR 
NEW_HOLDER JUST BECAME AN INFINITE LIST OF '+': [ '+', '+', '+', '+', '+', ...]
NOW I NEED TO FIGURE OUT HOW TO FIX IT!




def parse(holder):
	if len(holder) == 0:
		raise SyntaxError('unexpectedly entered function')
	
	token = holder[0]
	holder = holder[1:]

	if token == '[':
		new_holder = []
		while holder[0] != ']':
			new_holder.append(parse(holder))
		holder = holder[1:] #pops off the ')' part
	else:
		return token
	
holder = [ '[', '+', '1', '1', ']']
			
print parse(holder)


Using Python Tutor I realized that I needed to return the state of the content too (and
not just the token to be added to new_list) otherwise it would just go back to the previous
version of content, and we would not have made any progress. 
So then I changed my code to THIS: 

def parse(holder):
	if len(holder) == 0:
		raise SyntaxError('unexpectedly entered function')
	
	token = holder[0]
	holder = holder[1:]

	if token == '[':
		new_holder = []
		while holder[0] != ']':
			new_holder.append(parse(holder))
		holder = holder[1:] #pops off the ')' part
		return new_holder
	else:
		return token, holder
	
holder = [ '[', '+', '1', '1', ']']	
		
print parse(holder)

Again, using Python Tutor I realized that things had got out of control here.  By doing 
two returns, my progra was actually thinking that I was appending both the token (which 
I wanted to append) and then the 'content' to the new_list.  THis is NOT what I wanted!
All I wanted was our new changed version of content to be remembered when we were finished
one step of the recursion. SO that explains why Kuan did what he did.  Indeed, if we plan on 
returning two things, only one of which we want appended, then we should tell the program 
that two things are being returned, and only one of them will correspond to the appending.  
Like this:


def parse(holder):
	if len(holder) == 0:
		raise SyntaxError('unexpectedly entered function')
	
	token = holder[0]
	holder = holder[1:]

	if token == '[':
		new_holder = []
		while holder[0] != ']':
			to_append, holder = parse(holder)
			new_holder.to_append
		holder = holder[1:] #pops off the ')' part
		return new_holder
	else:
		return token, holder
	
holder = [ '[', '+', '1', '1', ']']	
		
print parse(holder)


Now, this code works when we don't have layers of nesting.  But when we do, it doesn't
work.  When we input something like: 
[ '[','+','[', '+', '1', '1', ']', '[', '+', '1', '1', ']', ']']
then we go through deeper levels of recursion. What I mean is that we basically go through 
two versions of the while loop.  This means that we end up with two new_holder lists. 
THe first contains the +, and the secon contains the + 1 1.  But then as soon as we exit
that loop, the second one dissapears.  We need a way to input the second one as an ELEMENT
of the first one!!! AHHH HOW TO DO THIS!?

def parse(holder):
	if len(holder) == 0:
		raise SyntaxError('unexpectedly entered function')
	
	token = holder[0]
	holder = holder[1:]

	if token == '[':
		new_holder = []
		while holder[0] != ']':
			to_append, holder = parse(holder)
			new_holder.to_append
		holder = holder[1:] #pops off the ')' part
		return new_holder, holder
		
	else:
		return token, holder
	
holder = [ '[', '+', '1', '1', ']']	
		
print parse(holder)



Well, the above code works, except that since I'm always returning new holder and holder, 
my final "return" ends up being a two element list: the frist element being new_holder, 
the second element being an empty list (holder).
To get around this I added an if statement on the return, to check if it was the last
return or not. 
MY FINAL PARSER LOOKED LIKE THIS:

def parse(holder):
	if len(holder) == 0:
		raise SyntaxError('unexpectedly entered function')
	
	token = holder[0]
	holder = holder[1:]

	if token == '[':
		new_holder = []
		while holder[0] != ']':
			to_append, holder = parse(holder)
			new_holder.append(to_append)
		holder = holder[1:] #pops off the ')' part
		
		#the following conditional statement prevents us from returning a two element 
		# on our very last return, since all we want is new holder
		if len(holder)>0:
			return new_holder, holder
		elif len(holder) == 0:
			return new_holder
	else:
		return token, holder

Kuan used another method, instaed he added some sort of wrapper: 

def wrapperRun(contentInput):
	read = readContentIn(contentInput)
	parsedList, _ = parseContent('', read)
	return parsedList



		